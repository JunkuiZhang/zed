/// TODO:
#[cfg(target_os = "windows")]
pub mod keycodes;

use collections::HashMap;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::{error::Error, fmt::Display};
#[cfg(target_os = "windows")]
use util::ResultExt;

#[cfg(target_os = "windows")]
pub use keycodes::*;

/// TODO:
#[cfg(target_os = "windows")]
pub type KeystrokeKey = KeyCodes;
/// TODO:
#[cfg(not(target_os = "windows"))]
pub type KeystrokeKey = String;

/// A keystroke and associated metadata generated by the platform
#[derive(Clone, Debug, Eq, PartialEq, Default, Hash)]
pub struct Keystroke {
    /// the state of the modifier keys at the time the keystroke was generated
    pub modifiers: Modifiers,

    /// key is the character printed on the key that was pressed
    /// e.g. for option-s, key is "s"
    pub key: KeystrokeKey,
    /// key_char is the character that could have been typed when
    /// this binding was pressed.
    /// e.g. for s this is "s", for option-s "ร", and cmd-s None
    pub key_char: Option<String>,
}

/// Error type for `Keystroke::parse`. This is used instead of `anyhow::Error` so that Zed can use
/// markdown to display it.
#[derive(Debug)]
pub struct InvalidKeystrokeError {
    /// The invalid keystroke.
    pub keystroke: String,
}

impl Error for InvalidKeystrokeError {}

impl Display for InvalidKeystrokeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Invalid keystroke \"{}\". {}",
            self.keystroke, KEYSTROKE_PARSE_EXPECTED_MESSAGE
        )
    }
}

/// Sentence explaining what keystroke parser expects, starting with "Expected ..."
pub const KEYSTROKE_PARSE_EXPECTED_MESSAGE: &str = "Expected a sequence of modifiers \
    (`ctrl`, `alt`, `shift`, `fn`, `cmd`, `super`, or `win`) \
    followed by a key, separated by `-`.";

impl Keystroke {
    /// When matching a key we cannot know whether the user intended to type
    /// the key_char or the key itself. On some non-US keyboards keys we use in our
    /// bindings are behind option (for example `$` is typed `alt-รง` on a Czech keyboard),
    /// and on some keyboards the IME handler converts a sequence of keys into a
    /// specific character (for example `"` is typed as `" space` on a brazilian keyboard).
    ///
    /// This method assumes that `self` was typed and `target' is in the keymap, and checks
    /// both possibilities for self against the target.
    pub(crate) fn should_match(&self, target: &Keystroke) -> bool {
        // if let Some(key_char) = self
        //     .key_char
        //     .as_ref()
        //     .filter(|key_char| key_char != &&self.key)
        // {
        //     let ime_modifiers = Modifiers {
        //         control: self.modifiers.control,
        //         platform: self.modifiers.platform,
        //         ..Default::default()
        //     };

        //     if &target.key == key_char && target.modifiers == ime_modifiers {
        //         return true;
        //     }
        // }

        target.modifiers == self.modifiers && target.key == self.key
    }

    /// key syntax is:
    /// [secondary-][ctrl-][alt-][shift-][cmd-][fn-]key[->key_char]
    /// key_char syntax is only used for generating test events,
    /// secondary means "cmd" on macOS and "ctrl" on other platforms
    /// when matching a key with an key_char set will be matched without it.
    #[cfg_attr(target_os = "windows", allow(unused_variables))]
    pub fn parse(
        source: &str,
        char_based_matching: bool,
        key_equivalents: Option<&HashMap<char, char>>,
    ) -> std::result::Result<Self, InvalidKeystrokeError> {
        let mut control = false;
        let mut alt = false;
        let mut shift = false;
        let mut platform = false;
        let mut function = false;
        let mut key = None;
        let mut key_char = None;

        let mut components = source.split('-').peekable();
        while let Some(component) = components.next() {
            match component {
                "ctrl" => control = true,
                "alt" => alt = true,
                "shift" => shift = true,
                "fn" => function = true,
                "secondary" => {
                    if cfg!(target_os = "macos") {
                        platform = true
                    } else {
                        control = true
                    };
                }
                "cmd" | "super" | "win" => platform = true,
                _ => {
                    if let Some(next) = components.peek() {
                        if next.is_empty() && source.ends_with('-') {
                            key = Some(String::from("-"));
                            break;
                        } else if next.len() > 1 && next.starts_with('>') {
                            key = Some(String::from(component));
                            key_char = Some(String::from(&next[1..]));
                            components.next();
                        } else {
                            return Err(InvalidKeystrokeError {
                                keystroke: source.to_owned(),
                            });
                        }
                    } else {
                        key = Some(String::from(component));
                    }
                }
            }
        }

        // Allow for the user to specify a keystroke modifier as the key itself
        // This sets the `key` to the modifier, and disables the modifier
        if key.is_none() {
            if shift {
                key = Some("shift".to_string());
                shift = false;
            } else if control {
                key = Some("control".to_string());
                control = false;
            } else if alt {
                key = Some("alt".to_string());
                alt = false;
            } else if platform {
                key = Some("platform".to_string());
                platform = false;
            } else if function {
                key = Some("function".to_string());
                function = false;
            }
        }

        let key = key.ok_or_else(|| InvalidKeystrokeError {
            keystroke: source.to_owned(),
        })?;
        #[cfg(not(target_os = "windows"))]
        let key = perform_mapping(key, char_based_matching, key_equivalents);
        #[cfg(target_os = "windows")]
        let key = perform_mapping(
            source,
            &key,
            char_based_matching,
            &mut shift,
            &mut control,
            &mut alt,
        )
        .log_err()
        .unwrap_or_else(|| {
            key_char = Some(key.clone());
            KeyCodes::Unknown(key)
        });

        Ok(Keystroke {
            modifiers: Modifiers {
                control,
                alt,
                shift,
                platform,
                function,
            },
            key,
            key_char,
        })
    }

    /// Produces a representation of this key that Parse can understand.
    pub fn unparse(&self) -> String {
        let mut str = String::new();
        if self.modifiers.function {
            str.push_str("fn-");
        }
        if self.modifiers.control {
            str.push_str("ctrl-");
        }
        if self.modifiers.alt {
            str.push_str("alt-");
        }
        if self.modifiers.platform {
            #[cfg(target_os = "macos")]
            str.push_str("cmd-");

            #[cfg(any(target_os = "linux", target_os = "freebsd"))]
            str.push_str("super-");

            #[cfg(target_os = "windows")]
            str.push_str("win-");
        }
        if self.modifiers.shift {
            str.push_str("shift-");
        }
        #[cfg(not(target_os = "windows"))]
        str.push_str(self.key.as_str());
        #[cfg(target_os = "windows")]
        str.push_str(self.key.unparse());
        str
    }

    /// Returns true if this keystroke left
    /// the ime system in an incomplete state.
    pub fn is_ime_in_progress(&self) -> bool {
        self.key_char.is_none()
            && (is_printable_key(&self.key) || is_empty_key(&self.key))
            && !(self.modifiers.platform
                || self.modifiers.control
                || self.modifiers.function
                || self.modifiers.alt)
    }

    /// Returns a new keystroke with the key_char filled.
    /// This is used for dispatch_keystroke where we want users to
    /// be able to simulate typing "space", etc.
    pub fn with_simulated_ime(mut self) -> Self {
        if self.key_char.is_none()
            && !self.modifiers.platform
            && !self.modifiers.control
            && !self.modifiers.function
            && !self.modifiers.alt
        {
            #[cfg(not(target_os = "windows"))]
            {
                self.key_char = match self.key.as_str() {
                    "space" => Some(" ".into()),
                    "tab" => Some("\t".into()),
                    "enter" => Some("\n".into()),
                    key if !is_printable_key(key) || is_empty_key(key) => None,
                    key => {
                        if self.modifiers.shift {
                            Some(key.to_uppercase())
                        } else {
                            Some(key.into())
                        }
                    }
                };
            }
            #[cfg(target_os = "windows")]
            {
                self.key_char = match &self.key {
                    KeyCodes::Space => Some(" ".into()),
                    KeyCodes::Tab => Some("\t".into()),
                    KeyCodes::Enter => Some("\n".into()),
                    key if !is_printable_key(key) || is_empty_key(key) => None,
                    key => Some(key.to_output_string(self.modifiers.shift)),
                };
            }
        }
        self
    }
}

#[cfg(not(target_os = "windows"))]
fn is_printable_key(key: &str) -> bool {
    !matches!(
        key,
        "f1" | "f2"
            | "f3"
            | "f4"
            | "f5"
            | "f6"
            | "f7"
            | "f8"
            | "f9"
            | "f10"
            | "f11"
            | "f12"
            | "f13"
            | "f14"
            | "f15"
            | "f16"
            | "f17"
            | "f18"
            | "f19"
            | "backspace"
            | "delete"
            | "left"
            | "right"
            | "up"
            | "down"
            | "pageup"
            | "pagedown"
            | "insert"
            | "home"
            | "end"
            | "back"
            | "forward"
            | "escape"
    )
}

#[cfg(target_os = "windows")]
fn is_printable_key(key: &KeyCodes) -> bool {
    !matches!(
        key,
        KeyCodes::F1
            | KeyCodes::F2
            | KeyCodes::F3
            | KeyCodes::F4
            | KeyCodes::F5
            | KeyCodes::F6
            | KeyCodes::F7
            | KeyCodes::F8
            | KeyCodes::F9
            | KeyCodes::F10
            | KeyCodes::F11
            | KeyCodes::F12
            | KeyCodes::F13
            | KeyCodes::F14
            | KeyCodes::F15
            | KeyCodes::F16
            | KeyCodes::F17
            | KeyCodes::F18
            | KeyCodes::F19
            | KeyCodes::F20
            | KeyCodes::F21
            | KeyCodes::F22
            | KeyCodes::F23
            | KeyCodes::F24
            | KeyCodes::Backspace
            | KeyCodes::Delete
            | KeyCodes::Left
            | KeyCodes::Up
            | KeyCodes::Right
            | KeyCodes::Down
            | KeyCodes::PageUp
            | KeyCodes::PageDown
            | KeyCodes::Insert
            | KeyCodes::Home
            | KeyCodes::End
            | KeyCodes::BrowserBack
            | KeyCodes::BrowserForward
            | KeyCodes::Escape
    )
}

#[cfg(not(target_os = "windows"))]
fn is_empty_key(key: &str) -> bool {
    key.is_empty()
}

#[cfg(target_os = "windows")]
fn is_empty_key(key: &KeyCodes) -> bool {
    *key == KeyCodes::Unknown("".into())
}

impl std::fmt::Display for Keystroke {
    #[cfg(not(target_os = "windows"))]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use std::fmt::Write;

        if self.modifiers.control {
            f.write_char('^')?;
        }
        if self.modifiers.alt {
            f.write_char('โฅ')?;
        }
        if self.modifiers.platform {
            #[cfg(target_os = "macos")]
            f.write_char('โ')?;

            #[cfg(any(target_os = "linux", target_os = "freebsd"))]
            f.write_char('โ')?;

            #[cfg(target_os = "windows")]
            f.write_char('โ')?;
        }
        if self.modifiers.shift {
            f.write_char('โง')?;
        }
        let key = match self.key.as_str() {
            "backspace" => 'โซ',
            "up" => 'โ',
            "down" => 'โ',
            "left" => 'โ',
            "right" => 'โ',
            "tab" => 'โฅ',
            "escape" => 'โ',
            "shift" => 'โง',
            "control" => 'โ',
            "alt" => 'โฅ',
            "platform" => 'โ',
            key => {
                if key.len() == 1 {
                    key.chars().next().unwrap().to_ascii_uppercase()
                } else {
                    return f.write_str(key);
                }
            }
        };
        f.write_char(key)
    }

    #[cfg(target_os = "windows")]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.modifiers.control {
            f.write_str("Ctrl")?;
        }
        if self.modifiers.alt {
            f.write_str("Alt")?;
        }
        if self.modifiers.platform {
            f.write_str("Win")?;
        }
        if self.modifiers.shift {
            f.write_str("Shift")?;
        }
        f.write_str(&self.key.display())
    }
}

/// The state of the modifier keys at some point in time
#[derive(Copy, Clone, Debug, Eq, PartialEq, Default, Serialize, Deserialize, Hash, JsonSchema)]
pub struct Modifiers {
    /// The control key
    #[serde(default)]
    pub control: bool,

    /// The alt key
    /// Sometimes also known as the 'meta' key
    #[serde(default)]
    pub alt: bool,

    /// The shift key
    #[serde(default)]
    pub shift: bool,

    /// The command key, on macos
    /// the windows key, on windows
    /// the super key, on linux
    #[serde(default)]
    pub platform: bool,

    /// The function key
    #[serde(default)]
    pub function: bool,
}

impl Modifiers {
    /// Returns whether any modifier key is pressed.
    pub fn modified(&self) -> bool {
        self.control || self.alt || self.shift || self.platform || self.function
    }

    /// Whether the semantically 'secondary' modifier key is pressed.
    ///
    /// On macOS, this is the command key.
    /// On Linux and Windows, this is the control key.
    pub fn secondary(&self) -> bool {
        #[cfg(target_os = "macos")]
        {
            self.platform
        }

        #[cfg(not(target_os = "macos"))]
        {
            self.control
        }
    }

    /// Returns how many modifier keys are pressed.
    pub fn number_of_modifiers(&self) -> u8 {
        self.control as u8
            + self.alt as u8
            + self.shift as u8
            + self.platform as u8
            + self.function as u8
    }

    /// Returns [`Modifiers`] with no modifiers.
    pub fn none() -> Modifiers {
        Default::default()
    }

    /// Returns [`Modifiers`] with just the command key.
    pub fn command() -> Modifiers {
        Modifiers {
            platform: true,
            ..Default::default()
        }
    }

    /// A Returns [`Modifiers`] with just the secondary key pressed.
    pub fn secondary_key() -> Modifiers {
        #[cfg(target_os = "macos")]
        {
            Modifiers {
                platform: true,
                ..Default::default()
            }
        }

        #[cfg(not(target_os = "macos"))]
        {
            Modifiers {
                control: true,
                ..Default::default()
            }
        }
    }

    /// Returns [`Modifiers`] with just the windows key.
    pub fn windows() -> Modifiers {
        Modifiers {
            platform: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with just the super key.
    pub fn super_key() -> Modifiers {
        Modifiers {
            platform: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with just control.
    pub fn control() -> Modifiers {
        Modifiers {
            control: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with just alt.
    pub fn alt() -> Modifiers {
        Modifiers {
            alt: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with just shift.
    pub fn shift() -> Modifiers {
        Modifiers {
            shift: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with command + shift.
    pub fn command_shift() -> Modifiers {
        Modifiers {
            shift: true,
            platform: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with command + shift.
    pub fn control_shift() -> Modifiers {
        Modifiers {
            shift: true,
            control: true,
            ..Default::default()
        }
    }

    /// Checks if this [`Modifiers`] is a subset of another [`Modifiers`].
    pub fn is_subset_of(&self, other: &Modifiers) -> bool {
        (other.control || !self.control)
            && (other.alt || !self.alt)
            && (other.shift || !self.shift)
            && (other.platform || !self.platform)
            && (other.function || !self.function)
    }
}

#[cfg(not(target_os = "windows"))]
fn perform_mapping(
    key: String,
    char_based_matching: bool,
    key_equivalents: Option<&HashMap<char, char>>,
) -> String {
    if char_based_matching {
        if let Some(equivalents) = key_equivalents {
            if key.chars().count() == 1 {
                if let Some(key) = equivalents.get(&key.chars().next().unwrap()) {
                    return key.to_string();
                }
            }
        }
    }
    key
}

#[cfg(target_os = "windows")]
fn perform_mapping(
    source: &str,
    input: &str,
    char_based_matching: bool,
    shift: &mut bool,
    control: &mut bool,
    alt: &mut bool,
) -> std::result::Result<KeystrokeKey, InvalidKeystrokeError> {
    let (keystroke_key, modifiers) =
        keystroke_remapping(input, char_based_matching).map_err(|_| InvalidKeystrokeError {
            keystroke: input.to_owned(),
        })?;
    if *shift && modifiers.shift {
        log::error!("Keystroke remapping conflict detected while mapping \"{}\"! {} is remapped to shift-{:?}, but shift is already pressed",source, input, keystroke_key);
    } else {
        *shift |= modifiers.shift;
    }
    if *control && modifiers.control {
        log::error!("Keystroke remapping conflict detected while mapping \"{}\"! {} is remapped to ctrl-{:?}, but ctrl is already pressed",source, input, keystroke_key);
    } else {
        *control |= modifiers.control;
    }
    if *alt && modifiers.alt {
        log::error!("Keystroke remapping conflict detected while mapping \"{}\"! {} is remapped to alt-{:?}, but alt is already pressed",source, input, keystroke_key);
    } else {
        *alt |= modifiers.alt;
    }
    Ok(keystroke_key)
}

// #[cfg(test)]
// mod test {
//     use super::Keystroke;

//     #[test]
//     fn test_basic_keystroke_parse() {
//         let input = "shift-pageup";
//         let keystroke = Keystroke::parse(input, false).unwrap();
//         println!("Keystroke: {:?}", keystroke);
//     }
// }
